package org.usgs.manifold.packet.data;

import java.util.HashMap;
import org.usgs.manifold.utilities.DatabaseHelper;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import org.jboss.netty.buffer.ChannelBuffer;
import org.jboss.netty.buffer.ChannelBuffers;

import org.jboss.netty.channel.group.ChannelGroup;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.usgs.manifold.ConfigurationPacket;
import org.usgs.manifold.Initialize;

import org.usgs.manifold.database.DatabaseInsertStatement;
import org.usgs.manifold.utilities.Time;

/**
 * Static methods to help with sending GPS data to where it needs to go.
 *
 */
public class SendGPS {

    private static Logger log = LoggerFactory.getLogger(SendGPS.class);
    private static ConfigurationPacket config = Initialize.getPacketConfig();

    /** The body of an SQL create table statement for GPS data. */
    //public static final String tableCreation = "(t DOUBLE PRIMARY KEY, "
    //        + "latitude DOUBLE, longitude DOUBLE, rawGPS BLOB)";
    public static final String tableCreation = "(j2ksec DOUBLE PRIMARY KEY, "
            + "latitude DOUBLE, longitude DOUBLE, rawGPS BLOB)";

    /** The body of an SQL insert statement for GPS data. */
    //private static final String insertStatement = "(t, rawGPS) VALUES (?,?);";
    private static final String insertStatement = "(j2ksec, rawGPS) VALUES (?,?);";

    /** The database table definition for GPS data. */
    private static final Map<String, String> tableDefinition =
            new HashMap<String, String>();
    static {
        //tableDefinition.put("t",         "double");
        tableDefinition.put("j2ksec",    "double");
        tableDefinition.put("latitude",  "double");
        tableDefinition.put("longitude", "double");
        tableDefinition.put("rawGPS",    "blob"  );
    }

    /** Holds SQL statements. */
    private static BlockingQueue<DatabaseInsertStatement> statements = null;

    /** Mapping of ports to channels. */
    private static Map<Integer, ChannelGroup> portChannelMap = null;

    // Prevent instantiation
    private SendGPS() {
    }

    /**
     * Sets the statement queue that is used by
     * {@link #sendToQueue(DataGPS) sendToDatabase}.
     *
     * @param statements a queue to hold {@link DatabaseInsertStatement}
     *        objects generated by
     *        {@link #sendToQueue(DataGPS) sendToDatabase}.
     */
    public static void setStatementQueue(
            BlockingQueue<DatabaseInsertStatement> statements) {

        SendGPS.statements = statements;
    }

    /**
     * Sets the port channel map that is used by
     * {@link #sendToChannel(DataGPS) sendToChannel}..
     *
     * @param portChannelMap the mapping of ports to channel groups that the
     *        server uses to sort connections.
     */
    public static void setChannelMap(
            Map<Integer, ChannelGroup> portChannelMap) {

        SendGPS.portChannelMap = portChannelMap;
    }

    /**
     * Generates a {@link DatabaseInsertStatement} object from the data in the
     * packet and offers it it to the queue specified by
     * {@link #setStatementQueue(BlockingQueue) setStatementQueue}.
     *
     * <p>
     * The database indicated in {@link GPS} is the database used in the 
     * creation of the {@link DatabaseInsertStatement} object.
     * 
     * @param gpsData the packet to send out.
     * @throws IllegalStateException if the statement queue has not been set.
     */
    public static void sendToQueue(DataGPS gpsData) {

        if (statements == null) {
            throw new IllegalStateException("GPS statement queue has not "
                    + "been set.");
        }

        //String table = DatabaseHelper.getTableName(gpsData);

        String table = DatabaseHelper.getTableName(gpsData, config.GPS_SATION_NAME_MAP);

        //TODO: Remove
        System.out.println("Table: " + table);

        // Define the parameters to insert.
        double time = Time.toJ2KSeconds(gpsData.getTime());
        byte[] data = gpsData.getData();

        DatabaseInsertStatement dbStatement = new DatabaseInsertStatement(
                table, config.GPS_DATABASE, tableDefinition, tableCreation,
                insertStatement, time, data);

        if (!statements.offer(dbStatement)) {
            log.warn("Can not insert GPS data into database due to a full "
                    + "queue.\nData will be discarded.");
        }
    }

    /**
     * Send out the gpsData data to a channel based on the station port map
     * specified in {@link GPS} and the port channel map specified by
     * {@link #setChannelMap(Map) setChannelMap}.
     *
     * @param gpsData the packet to send out.
     * @throws IllegalStateException if the port channel map has not set.
     */
    public static void sendToChannel(DataGPS gpsData) {

        if (portChannelMap == null) {
            throw new IllegalStateException("GPS port channel map has not "
                    + "been set.");
        }

        // Wrap data in channel buffer for output to a channel
        ChannelBuffer output =
                ChannelBuffers.wrappedBuffer(gpsData.getData());

        // Get the station number to map to the port to map to the channel.
        int stationNumber = gpsData.getHeader().getStationNumber();

        if (config.GPS_STATION_TO_PORT_MAP.containsKey(stationNumber)) {
            int port = config.GPS_STATION_TO_PORT_MAP.get(stationNumber);

            if (portChannelMap.containsKey(port)) {
                portChannelMap.get(port).write(output);
            } else {
                log.error("GPS port '{}' has not been assigned a channel."
                        + "\nThis should have been done in the Initialize "
                        + "phase.", port);
            }
        } else {
            log.warn("GPS station number '{}' has not been assigned a port."
                    + "\nGPS data from the station will not be sent to any "
                    + "connections.", stationNumber);
        }
    }
}
